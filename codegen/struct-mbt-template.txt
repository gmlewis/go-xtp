{{ $name := .Name }}{{ $top := . }}/// `{{ $name }}` represents {{ .Description | downcaseFirst }}.
pub struct {{ $name }} {
{{range .Properties}}  {{ .Description | optionalMbtMultilineComment }}{{ .Name | lowerSnakeCase }} : {{ getMbtType . }}
{{ end -}}
} derive(Show, Eq)

/// `{{ $name }}::new` returns a new struct with default values.
pub fn {{ $name }}::new() -> {{ $name }} {
  {
{{range .Properties}}    {{ .Name | lowerSnakeCase }}: {{ defaultMbtValue . }},
{{ end -}}
{{ "  }" }}
}

pub impl @jsonutil.ToJson for {{ $name }} with to_json(self) {
  let fields : Array[(String, @jsonutil.ToJson)] = [
{{range .Properties}}{{ if .IsRequired }}    ("{{ .Name }}", self.{{ .Name | lowerSnakeCase }}),
{{ end }}{{ end -}}
{{ "  ]" }}
{{range .Properties}}{{ if .IsRequired | not }}  match self.{{ .Name | lowerSnakeCase }} {
    Some(value) => fields.append([("{{ .Name }}", value)])
    None => ()
  }
{{ end }}{{ end -}}
{{ "  @jsonutil.from_entries(fields)" }}
}

/// `{{ $name }}::from_json` transforms a `Json` to a value.
pub fn {{ $name }}::from_json(value : Json) -> {{ $name }}? {
  let value = value.as_object()?
{{range .Properties}}  let {{ .Name | lowerSnakeCase }} = {{ mbtConvertFromJSONValue . }}
{{ end -}}
{{ "  match (" }}
{{range .Properties}}    {{ .Name | lowerSnakeCase }},
{{ end -}}
{{ "  ) {" }}{{ if len .Properties | lt 1 }}
    ({{ end }}
{{range .Properties}}{{ if .IsRequired }}      Some({{ .Name | lowerSnakeCase }}){{ if len $top.Properties | lt 1 }}{{ "," }}{{ end }}
{{ end }}{{ if .IsRequired | not }}      {{ .Name | lowerSnakeCase }}{{ if len $top.Properties | lt 1 }}{{ "," }}{{ end }}
{{ end }}{{ end -}}
{{ if len .Properties | lt 1 }}{{"    ) => Some({" }}{{ else }}{{"    => Some({" }}{{ end }}
{{range .Properties}}      {{ .Name | lowerSnakeCase }},
{{ end -}}
{{ "    })" }}
    _ => None
  }
}

/// `{{ $name }}::parse` parses a JSON string and returns the value.
pub fn {{ $name }}::parse(s : String) -> {{ $name }}!String {
  match @json.parse(s)!! {
    Ok(jv) =>
      match {{ $name }}::from_json(jv) {
        Some(value) => value
        None => {
          raise "unable to parse {{ $name }} \{s}"
        }
      }
    Err(e) => {
      raise "unable to parse {{ $name }} \{s}: \{e}"
    }
  }
}

/// `get_schema` returns an `XTPSchema` for the `{{ $name }}`.
pub fn get_schema(self : {{ $name }}) -> XTPSchema {
  {
{{range .Properties}}    "{{ .Name }}": "{{ getExtismType . $top }}",
{{ end -}}
{{ "  }" }}
}
