{{ $name := .Name }}{{ $top := . }}/// `{{ $name }}` represents {{ .Description | downcaseFirst }}.
pub struct {{ $name }} {
{{range .Properties}}  {{ .Description | optionalMbtMultilineComment }}{{ .Name | lowerSnakeCase }} : {{ getMbtType . }}
{{ end -}}
} derive(Show, Eq)

/// `{{ $name }}::new` returns a new struct with default values.
pub fn {{ $name }}::new() -> {{ $name }} {
  {
{{range .Properties}}    {{ .Name | lowerSnakeCase }}: {{ defaultMbtValue . }},
{{ end -}}
{{ "  }" }}
}

pub fn to_json(self : {{ $name }}) -> Json {
  let json : Map[String, Json] = {  }
{{range .Properties}}{{ if .IsRequired }}  json["{{ .Name }}"] = self.{{ .Name | lowerSnakeCase }}.to_json()
{{ end }}{{ end -}}
{{range .Properties}}{{ if .IsRequired | not }}  match self.{{ .Name | lowerSnakeCase }} {
    Some({{ .Name | lowerSnakeCase }}) =>
      json["{{ .Name }}"] = {{ .Name | lowerSnakeCase }}.to_json()
    _ => ()
  }
{{ end }}{{ end -}}
{{ "  json.to_json()" }}
}

/// `{{ $name }}::from_json` transforms a `Json` to a value.
pub impl @json.FromJson for {{ $name }} with from_json(json, path) {
  let json = match json.as_object() {
    Some(json) => json
    e =>
      raise @json.JsonDecodeError(
        (path, "{{ $name }}::from_json: expected object, got \{e}"),
      )
  }
{{range .Properties}}  let {{ .Name | lowerSnakeCase }} : {{ getMbtType . }} = match json.get("{{ .Name }}") {
    Some({{ .Name | lowerSnakeCase }}) => @json.from_json!({{ .Name | lowerSnakeCase }})
    _ =>
      raise @json.JsonDecodeError(
        (path, "{{ $name }}::from_json:{{ .Name | lowerSnakeCase }}: expected {{ getMbtType . }}"),
      )
  }
{{ end -}}
{{ "  match (" }}
{{range .Properties}}    {{ .Name | lowerSnakeCase }},
{{ end -}}
{{ "  ) {" }}{{ if len .Properties | lt 1 }}
    ({{ end }}
{{range .Properties}}{{ if .IsRequired }}      Some({{ .Name | lowerSnakeCase }}){{ if len $top.Properties | lt 1 }}{{ "," }}{{ end }}
{{ end }}{{ if .IsRequired | not }}      {{ .Name | lowerSnakeCase }}{{ if len $top.Properties | lt 1 }}{{ "," }}{{ end }}
{{ end }}{{ end -}}
{{ if len .Properties | lt 1 }}{{"    ) => Some({" }}{{ else }}{{"    => Some({" }}{{ end }}
{{range .Properties}}      {{ .Name | lowerSnakeCase }},
{{ end -}}
{{ "    })" }}
    _ => None
  }
}

/// `{{ $name }}::parse` parses a JSON string and returns the value.
pub fn {{ $name }}::parse(s : String) -> {{ $name }}!String {
  match @json.parse(s)!! {
    Ok(jv) =>
      match {{ $name }}::from_json(jv) {
        Some(value) => value
        None => {
          raise "unable to parse {{ $name }} \{s}"
        }
      }
    Err(e) => {
      raise "unable to parse {{ $name }} \{s}: \{e}"
    }
  }
}

/// `get_schema` returns an `XTPSchema` for the `{{ $name }}`.
pub fn get_schema(self : {{ $name }}) -> XTPSchema {
  {
{{range .Properties}}    "{{ .Name }}": "{{ getExtismType . $top }}",
{{ end -}}
{{ "  }" }}
}
